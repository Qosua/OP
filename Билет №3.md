> [!Вопросы]
> 1. Дайте определение понятиям: класс, объект, член класса, поле, метод, модификатор доступа, инкапсуляция в контексте C++. 
> 2. Объясните концепцию конструкторов и деструкторов, операторов присваивания, “правила трех”, а также способы их автоматической генерации компилятором.
> 3. Какова роль списков инициализации в конструкторах и концепция делегирующих конструкторов? Почему они важны? 
> 4. На примере класса String продемонстрируйте правильное определение вышеупомянутых методов.
### Определения основных понятий

**Класс**  
это пользовательский тип данных, который инкапсулирует данные (поля) и методы для работы с ними. 

**Объект**  
экземпляр класса, созданный в памяти.  

**Член класса**  
Любой элемент, объявленный внутри класса: поля, методы, вложенные классы.  

``` cpp
class String {
    char* buffer; // поле-член
    size_t size;  // поле-член
public:
    size_t length() { return size; } // метод-член
};
```

**Поле**  
Переменная, объявленная в классе. Хранит состояние объекта.  

**Метод**  
Функция, объявленная внутри класса и работающая с его полями.  

**Модификатор доступа**  
Ключевые слова `public`, `private`, `protected`, определяющие область видимости/доступность членов класса из вне.  

``` cpp
class String {
private:
    char* buffer; // доступ только внутри класса
public:
    size_t length(); // доступ извне
protected:
    char elem(int index); // доступ только дял наследников с учётом модификатора 
				     // наследования
};
```

**Инкапсуляция**  
Принцип сокрытия внутренней реализации класса. Поля обычно объявляются `private`, а взаимодействие с ними происходит через публичные методы.

---
### Конструкторы и деструкторы

**Конструктор**  
Специальный метод для инициализации объекта. Вызывается при создании объекта.  

``` cpp
class String {
public:
    String() { buffer = nullptr; } // конструктор по умолчанию
};
```

**Деструктор**  
Метод для освобождения ресурсов. Вызывается при уничтожении объекта.  

``` cpp
class String {
public:
    ~String() { delete[] buffer; } // деструктор
};
```

**Оператор присваивания**  
Определяет поведение при присваивании одного объекта другому (`operator=`).  

``` cpp
String& operator=(const String& other) {
    if (this != &other) {
        delete[] buffer;
        buffer = new char[strlen(other.buffer) + 1];
        strcpy(buffer, other.buffer);
    }
    return *this;
}
```

**Правило трех**  
Если класс требует определения одного из следующих методов, он требует всех трех:

1. Деструктор.
2. Копирующий конструктор.
3. Оператор присваивания.

Причина: классы, управляющие ресурсами (например, динамической памятью), должны корректно копировать и освобождать их.

**Авто генерация компилятором**  
Компилятор автоматически генерирует конструкторы, деструктор и оператор присваивания, если они не объявлены. Однако для классов с динамической памятью авто генерация не подходит (например, копирование указателей вместо данных).

---
### Списки инициализации и делегирующие конструкторы

**Список инициализации**  
Позволяет инициализировать поля до выполнения тела конструктора. Особенно важно для:

- Константных полей (`const`).
    
- Ссылок (`&`).
    
- Объектов без конструктора по умолчанию.

``` cpp
class String {
    char* buffer;
    size_t size;
public:
    String(const char* str) : buffer(new char[strlen(str) + 1]), size(strlen(str)) {
        strcpy(buffer, str);
    }
};
```

**Делегирующие конструкторы**  
Конструктор может вызывать другой конструктор того же класса для избежания дублирования кода.  

``` cpp
class String {
public:
    String() : String("") {} // делегирует конструктору с параметром
    String(const char* str) { ... }
};
```
